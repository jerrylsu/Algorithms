## Binary Search

一般而言，当一个题目出现以下特性时，应该立即联想到它可能需要使用二分查找：

- 待查找的数组有序或者部分有序
- 要求时间复杂度低于O(n)，或者直接要求时间复杂度为O(log n)

二分查找法的前置条件要拥有一个已经Sorted好的序列，这样在查找所要查找的元素时, 首先与序列中间的元素进行比较, 如果大于这个元素, 就在当前序列的后半部分继续查找, 如果小于这个元素, 就在当前序列的前半部分继续查找, 直到找到相同的元素, 或者所查找的序列范围为空为止。

二分查找有很多种变体，使用时需要注意查找条件，判断条件和左右边界的更新方式，三者配合不好就很容易出现死循环或者遗漏区域，几种查找方式的模板代码，包括：

- 标准的二分查找
- 二分查找左边界
- 二分查找右边界
- 二分查找左右边界
- 二分查找极值点

### 标准的二分查找

```
# 标准的二分查找模板

def binarySearch(arr, target):
    if not arr: return -1
    l , r = 0, len(arr) - 1  
    while l <= r:            
        mid = l + (l - r) // 2
        if arr[mid] == target: 
            return mid
        if target > arr[mid]:
            l = mid + 1
        else:
            r = mid - 1 
    return -1
```
- 循环条件： l <= r
- 中间位置计算： mid = l + ((r -l) >> 1)
- 左边界更新：l = mid + 1
- 右边界更新： r = mid - 1
- 返回值： mid / -1

注：
1. 我们的循环条件中包含了 l == r，则我们必须在每次循环中改变 l 和 r，以防止进入死循环。
2. 循环终止的条件包括：
    - 找到target
    - l > r （l, mid, r，这个数还不是目标值，则整个查找结束。）
3. l + ((r -l) >> 1) 一个是为了防止 (l + r)出现溢出，一个是用右移操作替代除法提升性能。
4. l + ((r -l) >> 1) 对于目标区域长度为奇数而言，是处于正中间的，对于长度为偶数而言，是中间偏左的。因此左右边界相遇时，只会是以下两种情况：
    - l&mid , r (l, mid 指向同一个数，r)
    - l&mid&r（l, mid, r 指向同一个数）即因为mid对于长度为偶数的区间总是偏左的，所以当区间长度小于等于2时，mid 总是和 left在同一侧。

374.Guess Number Higher or Lower

 ### 二分查找左边界
利用二分法寻找左边界是二分查找的一个变体，应用它的题目常常有以下几种特性之一：

1. 数组有序，但包含重复元素
2. 数组部分有序，且不包含重复元素
3. 数组部分有序，且包含重复元素

#### 左边界查找类型1


#### 左边界查找类型2


[Binary Search总结](https://github.com/yuzhoujr/leetcode/issues/8)